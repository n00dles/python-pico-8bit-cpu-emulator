import re   

class Compile:
    
    def __init__(self):
        self.regex = "^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,4})(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?"
        
        # Regex group indexes for operands
        self.op1_group = 3
        self.op2_group = 7

        # MATCHES: "(+|-)INTEGER"
        self.regexNum = "^[-+]?[0-9]+$"
        # MATCHES: "(.L)abel"
        self.regexLabel = "^[.A-Za-z]\w*$"
        # Contains the program code & data generated by the assembler
        self.code = []
        # Contains the mapping from instructions to assembler line
        self.mapping = {}
        # Hash map of label used to replace the labels after the assembler generated the code
        self.labels = {}
        # Hash of uppercase labels used to detect duplicates
        self.normalizedLabels = {}

        # Split text into code lines
        #lines = input.split('\n')
        
        # s = "      MOV A, 0x54"
        # match = self.exec(self.regex,s)
        # print(match)

    def parseNumber(self,input):
        if input[0:2] == "0x":
            return int(input[2:], 16)
        elif  input[0:2] == "0o":
            return int(input[2:], 8);
        elif  input[len(input) - 1] == "b":
            return int(input[0: len(input) - 1], 2)
        elif  input[len(input) - 1] == "d":
            return int(input[0:len(input) - 1], 10)
        elif self.exec(self.regexNum, input):
            return int(input, 10)
        else:
            print("Invalid number format")

    def parseRegister(self,input):
        input = input.upper()

        if input == 'A':
            return 0
        elif (input == 'B'):
            return 1
        elif (input == 'C'):
            return 2
        elif (input == 'D'):
            return 3
        elif (input == 'SP'):
            return 4
        else:
            return None

    def parseOffsetAddressing(self,input):
                input = input.upper()
                m = 0
                base = 0

                if input[0] == 'A':
                    base = 0
                elif input[0] == 'B':
                    base = 1
                elif input[0] == 'C':
                    base = 2
                elif input[0] == 'D':
                    base = 3
                elif input.slice(0, 2) == "SP":
                    base = 4
                else:
                    return None
                
                offset_start = 1
                if base == 4:
                    offset_start = 2
                

                if input[offset_start] == '-':
                    m = -1
                elif input[offset_start] == '+':
                    m = 1
                else:
                    return None
                

                offset = m * int(input[offset_start + 1], 10)

                if offset < -16 or offset > 15:
                    print("offset must be a value between -16...+15")

                if offset < 0:
                    offset = 32 + offset # two's complement representation in 5-bit

                return offset * 8 + base # shift offset 3 bits right and add code for register

    def parseLabel(self,input):
        label = re.search(self.regexLabel,input)
        if label:
            return input
        else:
            return None

    def exec(self,regex, s):
        m = re.search(regex, s)
        if m:
            return [s for s in m.groups()]


c = Compile()
print(c.parseLabel(".loop"))